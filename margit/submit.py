import sys
import margit
from margit.utils import get_template
import datetime
from argparse import ArgumentParser
import yaml

import os
import stat
import os.path

from glob import glob
from threading import Thread
import time
import shutil

from copy import deepcopy


@margit.cli_command
def submit(args):
    "Makes a job out of a template and submit it"
    parser = ArgumentParser(usage="margit template <arguments>")
    parser.add_argument("command", help="Executable file to submit")
    parser.add_argument(
        "--template", "-t", help="Template job defining the environment", default=None)
    parser.add_argument("--njobs", "-n", default=1,
                        help="Number of jobs to submit", type=int)
    parser.add_argument ("--quiet", "-q", action='store_true', 
                        help='Disable all info messages stderr')
    parser.add_argument ("--not-executable",  action='store_true', 
                        help='Disable all info messages stderr')

    submission_mode = parser.add_mutually_exclusive_group()
    submission_mode.add_argument("--local", "-L", action='store_true',
                                 help="Submit the job to local")
    submission_mode.add_argument("--wait", "-w", type=int, default=None,
        help="Submit the job to DIRAC, but blocks until it ends or after n seconds (0 waits forever)")
    parser.add_argument("--scratchdir", "-d", default=".margit-scratch",
        help="Scratch area to download jobs from DIRAC")
    parser.add_argument("--input", "-i", nargs='*', default=[],
        help="<source_path>:<sandbox_file> Partial copy of input files to the the input sandbox")
    parser.add_argument("--output", "-o", nargs='*', default=[],
        help="<sandbox_file>:<dest_path> Partial copy of the output sandbox to a given location")
    parser.add_argument("--options", nargs='*', default=[],
        help="Some template offers configurable variables that can be passed as <option_key>:<option_value>")

    args = parser.parse_args(args)
    if len(args.output) and args.wait is None:
      if any([':' not in a for a in args.output]):
        raise ValueError("--output format must be <sandbox_file>:<dest_path>")
      args.wait = 0

    parsed_inputs = [kv if ":" in kv else f'{kv}:{kv}' for kv in args.input]
    inputs = {s.split(':')[0]:s.split(':')[1] for s in parsed_inputs}
    outputs = {s.split(':')[0]:s.split(':')[1] for s in args.output}
    options = {s.split(':')[0]:s.split(':')[1] for s in args.options}

    template = get_template(args.template)

    if 'Options' not in template.keys() and len(args.options) > 0:
      raise RuntimeError("Options are not supported by the selected template")

    require_executable = not args.not_executable
    if template['RequireExecutable'] == False:
      require_executable = False


    ## Check the command is actually executable 
    if require_executable:
      try: 
        if not (os.stat(args.command).st_mode & stat.S_IXUSR):
          raise RuntimeError (
              f"File {args.command} is not executable (DIRAC may fail). "
              "Override passing --not-executable to margit submit")
      except FileNotFoundError:
        print (f'!!! WARNING !!! File "{args.command}" was not found (DIRAC may fail)',
            file=sys.stderr)


    ## Builds the name for the scratch dir
    if os.path.exists(args.scratchdir):
      bundle_path = os.path.join(args.scratchdir,
          "_".join([".margit-scratch", margit.utils.get_random_string()])
          )
    else:
      bundle_path = "_".join([args.scratchdir, margit.utils.get_random_string()])
    ######


    cfg_dict = dict(
        argument=args.command,
        margittemplates=margit.templates, 
        )


    if 'Options' in template.keys():
      cfg_dict.update(template['Options'])
      cfg_dict.update(options) 




    print("### DO NOT EDIT THIS FILE ###")
    print(yaml.dump(template))
    job = margit.core.get_job()
    job.setName(template['JobName'])
    setup = template['Setup']
    if isinstance(setup, str):
        setup = [setup]
    setup = '; '.join(sum([s.split('\n') for s in setup], []))
    setup = setup.format(**cfg_dict)

    command = template['Command'].format(**cfg_dict)

    if 'Destination' in template.keys():
      job.setDestination(template['Destination'])

    if 'DestinationCE' in template.keys():
      job.setDestinationCE(template['DestinationCE'])

    job.setLogLevel(template['LogLevel'])

    if 'Tags' in template.keys():
      job.setTag(template['Tags'])


    inputSB = [f.format(**cfg_dict)
               for f in template['InputSandBox']]

    if len(inputs):
      os.mkdir (bundle_path)
      bundled_files = [os.path.join(bundle_path, i) for i in inputs.values()]
      inputSB = list(set(inputSB + bundled_files))
      for path_from, file_to in inputs.items():
        shutil.copy2(path_from, os.path.join(bundle_path, file_to))

    if len(inputSB):
        job.setInputSandbox(inputSB)


    outputSB = list(set(template['OutputSandBox'] + list(outputs.keys())))
    if len(outputSB):
        job.setOutputSandbox(outputSB)

    if len(template['OutputData']) > 0:
        job.setOutputData(list(set(template['OutputData'])))

    if args.local:
        job.runLocal(margit.core.get_dirac())
        return

    ids = []
    try:
      for iJob in range(args.njobs):
          subjob = deepcopy (job)
          subjob.setDIRACPlatform()
          subjob.setExecutable(template['Executable'].format(**cfg_dict),
                            arguments=f""" "{setup}" "{command}" "{iJob}" """
                            )
          subjob.setExecutionEnv({})
          submission_report = margit.core.get_dirac().submitJob(subjob)
          print ("--- submission report ---", file=sys.stderr)
          print (submission_report, file=sys.stderr)
          print ("---------------------------", file=sys.stderr)
          ids.append(submission_report['JobID'])
    finally:
      if len(inputs): 
        shutil.rmtree(bundle_path)

    print("#"*80)
    print(yaml.dump({
        'JobID': ids,
        'submission': str(datetime.datetime.now())
    }))

    if args.wait is not None:
        t0 = time.time()
        while True:
            time.sleep(5)
            statuses = margit.core.get_dirac().getJobStatus(ids)
            statuses = [v['Status'] for v in statuses['Value'].values()]

            deadStatus = ['Done', 'Failed', 'Killed']
            nActive = len([s for s in statuses if s not in deadStatus])
            if nActive:
              if not args.quiet:
                print(f"Waiting for up to {nActive} job(s) to complete. Status of jobs: ", ", ".join(set(statuses)), file=sys.stderr)
            if args.wait != 0 and time.time() - t0 > args.wait:
                raise ConnectionError(
                    "Timeout, increase wait time (-w, --wait)")

            if nActive == 0:
                break

        if nActive == 0 and len(args.output):

          os.mkdir (bundle_path)
          try:
            for iJob, jobid in enumerate(ids, 1):
              margit.core.get_dirac().getOutputSandbox(jobid, outputDir=args.scratchdir)
              for file_from, path_to in outputs.items():
                modified_path_to = path_to + f".{iJob}" if len(ids) > 1 else path_to
                if "*" in file_from or "?" in file_from: 
                  downloaded_files = glob(os.path.join(args.scratchdir, str(jobid), file_from))
                  if len(downloaded_files) == 0:
                    status = 'NOT FOUND'
                  elif len(downloaded_files) > 1:
                    print (f"## Found {len(downloaded_files)} consistent with rule {file_from}  ->  {path_to}")
                    print (f"WARNING! Found {len(downloaded_files)} consistent with rule {file_from}  ->  {path_to}", 
                          file=sys.stderr)
                  else:
                    downloaded_file = downloaded_files[0]
                    status = 'Found'

                else:
                  downloaded_file = os.path.join(args.scratchdir, str(jobid), file_from)
                  status = 'Found' if os.path.exists(downloaded_file) else 'NOT FOUND'

                print (f"## Output file  ({file_from}  ->  {path_to}):  {status}")
                if status.lower() == 'found':
                  shutil.copy2(downloaded_file, modified_path_to)
          finally:
            print (f"Removing {args.scratchdir}", file=sys.stderr)
            shutil.rmtree(bundle_path)

        try:
          print (yaml.dump({status: statuses.count(status) for status in set(statuses)}), file=sys.stderr)
        except Exception:
          pass 
